require_relative "./libs/initialization.rb"
require_relative "./libs/communication.rb"
require_relative "./libs/chain_monitor.rb"
require "mongo"
require "thor"
Mongo::Logger.logger.level = Logger::FATAL

def pubkey_to_privkey(pubkey)
  @client = Mongo::Client.new(["127.0.0.1:27017"], :database => "GPC")
  @db = @client.database
  @coll_sessions = @db[pubkey + "_session_pool"]
  private_key = @coll_sessions.find({ id: 0 }).first[:privkey]
  return private_key
end

class GPCCLI < Thor
  desc "init <private-key>", "Init with the private key."
  # --------------init
  def init(private_key)
    if ARGV.length != 2
      puts "The arg number is not right."
      return false
    end
    Init.new(private_key)
  end

  # --------------listen
  desc "listen <pubkey> <port>", "Listen the port."

  def listen(pubkey, port = 1000)
    if ARGV.length != 3
      puts "The arg number is not right."
      return false
    end
    private_key = pubkey_to_privkey(pubkey)
    communicator = Communication.new(private_key)
    communicator.listen(port)
  end

  # --------------establishment
  desc "send_establishment_request --pubkey <public key> --ip <ip> \
        --port <port> --fee <fee in shannon> --since <since> \
        --funding <fundings>",
       "Send the chanenl establishment request."
  option :pubkey, :required => true
  option :ip, :required => true
  option :port, :required => true
  option :fee, :required => true
  option :since, :required => true
  option :funding, :required => true, :type => :hash

  def send_establishment_request()
    private_key = pubkey_to_privkey(options[:pubkey])
    communicator = Communication.new(private_key)
    fundings = options[:funding]

    fundings = fundings.map() { |key, value| [key.to_sym, value] }.to_h

    for asset_type in fundings.keys()
      fundings[asset_type] = asset_type == :ckb ? CKB::Utils.byte_to_shannon(BigDecimal(fundings[asset_type])) : BigDecimal(fundings[asset_type])
      fundings[asset_type] = fundings[asset_type].to_i
    end

    communicator.send_establish_channel(options[:ip], options[:port], fundings, options[:fee].to_i,
                                        options[:since])
  end

  # --------------make payments
  desc "make_payment --pubkey <public key> --ip <ip> --port <port> --id <id> --payment <payment>", "Make payments"

  option :pubkey, :required => true
  option :ip, :required => true
  option :port, :required => true
  option :id, :required => true
  option :payment, :required => true, :type => :hash

  def make_payment()
    @path_to_file = __dir__ + "/../../miscellaneous/files/"
    private_key = pubkey_to_privkey(options[:pubkey])
    @client = Mongo::Client.new(["127.0.0.1:27017"], :database => "GPC")
    @db = @client.database
    @coll_sessions = @db[options[:pubkey] + "_session_pool"]

    payment = options[:payment]
    payment = payment.map() { |key, value| [key.to_sym, value] }.to_h

    for asset_type in payment.keys()
      payment[asset_type] = asset_type == :ckb ? CKB::Utils.byte_to_shannon(BigDecimal(payment[asset_type])) : BigDecimal(payment[asset_type])
      payment[asset_type] = payment[asset_type].to_i
    end

    communicator = Communication.new(private_key)
    communicator.send_payments(options[:ip], options[:port], options[:id], payment)
  end

  # --------------monitor
  desc "monitor <public key>", "Monitor the chain."

  def monitor(pubkey)
    private_key = pubkey_to_privkey(pubkey)
    monitor = Minotor.new(private_key)
    monitor.monitor_chain()
  end

  # --------------close the channel unilateral
  desc "closing_channel <pubkey> <id>", "closing the channel with id."

  def closing_channel(pubkey, id)
    private_key = pubkey_to_privkey(pubkey)
    monitor = Minotor.new(private_key)

    @client = Mongo::Client.new(["127.0.0.1:27017"], :database => "GPC")
    @db = @client.database
    @coll_sessions = @db[pubkey + "_session_pool"]

    doc = @coll_sessions.find({ id: id }).first
    monitor.send_tx(doc, "closing")
  end

  # --------------send the closing request about bilateral closing.
  desc "send_closing_request --pubkey <public key> --ip <ip> --port <port> --id <id> --fee ", "The good case, bilateral closing."

  option :pubkey, :required => true
  option :ip, :required => true
  option :port, :required => true
  option :id, :required => true
  option :fee

  def send_closing_request()
    private_key = pubkey_to_privkey(options[:pubkey])
    communicator = Communication.new(private_key)
    communicator.send_closing_request(options[:ip], options[:port], options[:id], options[:fee].to_i) if options[:fee]
    communicator.send_closing_request(options[:ip], options[:port], options[:id]) if !options[:fee]
  end

  # --------------send_msg by payment channel.
  desc "send_tg_msg --pubkey <public key> --ip <ip> --port <port> --id <id>", "pay tg robot and he will send msg for you."

  option :pubkey, :required => true
  option :ip, :required => true
  option :port, :required => true
  option :id, :required => true

  def send_tg_msg()
    @path_to_file = __dir__ + "/../miscellaneous/files/"
    tg_msg_raw = File.read(@path_to_file + "tg_msg.json")
    tg_msg_json = JSON.parse(tg_msg_raw, symbolize_names: true)

    # prepare the msg you want to send.
    puts "Tell me who you are."
    # user_name = STDIN.gets.chomp
    user_name = tg_msg_json[:user_name]
    puts "Tell me who you want to mute."
    mute_id = tg_msg_json[:muted_id]
    puts "Tell me how long would you like to mute him."
    # mute_time = STDIN.gets.chomp
    mute_time = tg_msg_json[:time]
    # ask the type.
    puts "Tell me what type of asset you want to pay."
    # payment_type = STDIN.gets.chomp
    payment_type = tg_msg_json[:payment_type]
    # construct payment.

    if payment_type == "ckb"
      payment_amount = mute_time
    elsif payment_type == "udt"
      payment_amount = ((mute_time).to_f / 10).ceil
    end
    payment = { payment_type => payment_amount }
    payment = payment.map() { |key, value| [key.to_sym, value] }.to_h

    private_key = pubkey_to_privkey(options[:pubkey])

    for asset_type in payment.keys()
      payment[asset_type] = asset_type == :ckb ? CKB::Utils.byte_to_shannon(BigDecimal(payment[asset_type])) : BigDecimal(payment[asset_type])
      payment[asset_type] = payment[asset_type].to_i
    end

    communicator = Communication.new(private_key)
    communicator.send_payments(options[:ip], options[:port], options[:id], payment, tg_msg_json)
  end
end

$VERBOSE = nil
GPCCLI.start(ARGV)
